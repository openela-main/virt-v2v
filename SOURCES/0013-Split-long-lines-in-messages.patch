From bcd60820de1256ef4c36ced54efa1243902411f7 Mon Sep 17 00:00:00 2001
From: "Richard W.M. Jones" <rjones@redhat.com>
Date: Fri, 20 Jan 2023 09:58:10 +0000
Subject: [PATCH] Split long lines in messages

This commit splits up any long lines found in errors, warnings or
other messages.  OCaml ignores whitespace following "\<CR>" within a
string, eg:

  "long string \
   more stuff"

is parsed as:

  "long string more stuff"

Thanks: Laszlo Ersek, for working out the OCaml syntax for this
(cherry picked from commit d2b01e487ff4ef56d139a5e0f22efd9b2ed9b64c)
---
 convert/convert.ml               | 11 ++++++---
 convert/inspect_source.ml        | 42 ++++++++++++++++++++++++++------
 convert/target_bus_assignment.ml |  8 +++++-
 in-place/in_place.ml             | 16 +++++++++---
 input/OVA.ml                     | 14 ++++++++---
 input/OVF.ml                     | 10 +++++---
 input/input_disk.ml              |  6 +++--
 input/input_libvirt.ml           |  9 ++++---
 input/input_ova.ml               |  9 ++++---
 input/input_vcenter_https.ml     | 15 ++++++++----
 input/input_vddk.ml              | 16 +++++++++---
 input/input_xen_ssh.ml           |  9 ++++---
 input/nbdkit_vddk.ml             |  3 ++-
 input/parse_domain_from_vmx.ml   |  3 ++-
 input/parse_libvirt_xml.ml       | 28 ++++++++++++++-------
 input/vCenter.ml                 |  7 ++++--
 inspector/inspector.ml           | 26 ++++++++++++++------
 lib/create_ovf.ml                | 16 +++++++++---
 lib/libvirt_utils.ml             | 12 ++++++---
 lib/networks.ml                  | 15 ++++++++----
 lib/types.ml                     |  3 ++-
 lib/utils.ml                     |  7 ++++--
 output/create_libvirt_xml.ml     |  4 ++-
 output/output.ml                 |  3 ++-
 output/output_glance.ml          |  5 +++-
 output/output_kubevirt.ml        |  6 +++--
 output/output_libvirt.ml         | 20 ++++++++++++---
 output/output_null.ml            |  3 ++-
 output/output_openstack.ml       | 24 ++++++++++++------
 output/output_qemu.ml            |  3 ++-
 output/output_rhv.ml             | 36 +++++++++++++++++++++------
 output/output_rhv_upload.ml      | 39 ++++++++++++++++++++---------
 output/output_vdsm.ml            | 16 ++++++++----
 v2v/v2v.ml                       | 26 ++++++++++++++------
 34 files changed, 343 insertions(+), 127 deletions(-)

diff --git a/convert/convert.ml b/convert/convert.ml
index 8d62f6d4..d0d5b773 100644
--- a/convert/convert.ml
+++ b/convert/convert.ml
@@ -181,12 +181,14 @@ and check_guest_free_space inspect mpstats =
       let needed_bytes = Int64.of_int needed_megabytes *^ 1024L *^ 1024L in
       if free_bytes < needed_bytes then (
         let mb i = Int64.to_float i /. 1024. /. 1024. in
-        error (f_"not enough free space for conversion on filesystem ‘%s’.  %.1f MB free < %d MB needed")
+        error (f_"not enough free space for conversion on filesystem ‘%s’.  \
+                  %.1f MB free < %d MB needed")
           mp_path (mb free_bytes) needed_megabytes
       );
       (* Not all the filesystems have inode counts. *)
       if files > 0L && ffree < needed_inodes then
-        error (f_"not enough available inodes for conversion on filesystem ‘%s’.  %Ld inodes available < %Ld inodes needed")
+        error (f_"not enough available inodes for conversion on \
+                  filesystem ‘%s’.  %Ld inodes available < %Ld inodes needed")
           mp_path ffree needed_inodes
   ) mpstats
 
@@ -210,7 +212,10 @@ and do_fstrim g inspect =
       if mounted then (
         try g#fstrim "/"
         with G.Error msg ->
-          warning (f_"fstrim on guest filesystem %s failed.  Usually you can ignore this message.  To find out more read \"Trimming\" in virt-v2v(1).\n\nOriginal message: %s") dev msg
+          warning (f_"fstrim on guest filesystem %s failed.  Usually you \
+                      can ignore this message.  To find out more read \
+                      \"Trimming\" in virt-v2v(1).\n\n\
+                      Original message: %s") dev msg
       )
   ) fses
 
diff --git a/convert/inspect_source.ml b/convert/inspect_source.ml
index a0d9f148..9a6fdab7 100644
--- a/convert/inspect_source.ml
+++ b/convert/inspect_source.ml
@@ -45,8 +45,13 @@ let rec inspect_source root_choice g =
       (try g#mount dev mp
        with G.Error msg ->
          if mp = "/" then ( (* RHBZ#1145995 *)
-           if String.find msg "Windows" >= 0 && String.find msg "NTFS partition is in an unsafe state" >= 0 then
-             error (f_"unable to mount the disk image for writing. This has probably happened because Windows Hibernation or Fast Restart is being used in this guest. You have to disable this (in the guest) in order to use virt-v2v.\n\nOriginal error message: %s") msg
+           if String.find msg "Windows" >= 0 &&
+                String.find msg "NTFS partition is in an unsafe state" >= 0 then
+             error (f_"unable to mount the disk image for writing. This has \
+                       probably happened because Windows Hibernation or \
+                       Fast Restart is being used in this guest. You have \
+                       to disable this (in the guest) in order to use \
+                       virt-v2v.\n\nOriginal error message: %s") msg
            else
              error "%s" msg
          )
@@ -63,7 +68,12 @@ let rec inspect_source root_choice g =
         (try g#touch file
          with G.Error msg ->
            if g#last_errno () = G.Errno.errno_EROFS then
-             error (f_"filesystem was mounted read-only, even though we asked for it to be mounted read-write.  This usually means that the filesystem was not cleanly unmounted.  Possible causes include trying to convert a guest which is running, or using Windows Hibernation or Fast Restart.\n\nOriginal error message: %s") msg
+             error (f_"filesystem was mounted read-only, even though we \
+                       asked for it to be mounted read-write.  This usually \
+                       means that the filesystem was not cleanly unmounted.  \
+                       Possible causes include trying to convert a guest \
+                       which is running, or using Windows Hibernation or \
+                       Fast Restart.\n\nOriginal error message: %s") msg
            else
              error (f_"could not write to the guest filesystem: %s") msg
         );
@@ -128,7 +138,12 @@ let rec inspect_source root_choice g =
 
 and choose_root root_choice g = function
   | [] ->
-     error (f_"inspection could not detect the source guest (or physical machine).\n\nAssuming that you are running virt-v2v/virt-p2v on a source which is supported (and not, for example, a blank disk), then this should not happen.\n\nNo root device found in this operating system image.");
+     error (f_"inspection could not detect the source guest \
+               (or physical machine).\n\nAssuming that you are \
+               running virt-v2v/virt-p2v on a source which is \
+               supported (and not, for example, a blank disk), \
+               then this should not happen.\n\nNo root device \
+               found in this operating system image.");
   | [root] -> root (* only one root, so return it *)
   | roots ->
      (* If there are multiple roots, use the [--root] option supplied
@@ -138,7 +153,9 @@ and choose_root root_choice g = function
      | AskRoot ->
         (* List out the roots and ask the user to choose. *)
         printf "\n***\n";
-        printf (f_"Dual- or multi-boot operating system detected.  Choose the root filesystem\nthat contains the main operating system from the list below:\n");
+        printf (f_"Dual- or multi-boot operating system detected.  \
+                   Choose the root filesystem\nthat contains the main \
+                   operating system from the list below:\n");
         printf "\n";
         List.iteri (
           fun i root ->
@@ -165,7 +182,9 @@ and choose_root root_choice g = function
         List.nth roots (!i - 1)
 
       | SingleRoot ->
-        error (f_"multi-boot operating systems are not supported by virt-v2v. Use the --root option to change how virt-v2v handles this.")
+        error (f_"multi-boot operating systems are not supported by \
+                  virt-v2v. Use the --root option to change how virt-v2v \
+                  handles this.")
 
       | FirstRoot ->
         let root = List.hd roots in
@@ -185,7 +204,10 @@ and choose_root root_choice g = function
 and reject_if_not_installed_image g root =
   let fmt = g#inspect_get_format root in
   if fmt <> "installed" then
-    error (f_"libguestfs thinks this is not an installed operating system (it might be, for example, an installer disk or live CD).  If this is wrong, it is probably a bug in libguestfs.  root=%s fmt=%s") root fmt
+    error (f_"libguestfs thinks this is not an installed operating \
+              system (it might be, for example, an installer disk \
+              or live CD).  If this is wrong, it is probably a bug \
+              in libguestfs.  root=%s fmt=%s") root fmt
 
 (* Wrapper around g#inspect_list_applications2 which, for RPM
  * guests, on failure tries to rebuild the RPM database before
@@ -275,5 +297,9 @@ and sanity_check_inspection inspect =
 
 and error_if_unknown fieldname value =
   if value = "unknown" then
-    error (f_"inspection could not detect the source guest (or physical machine).\n\nAssuming that you are running virt-v2v/virt-p2v on a source which is supported (and not, for example, a blank disk), then this should not happen.\n\nInspection field ‘%s’ was ‘unknown’.")
+    error (f_"inspection could not detect the source guest (or \
+              physical machine).\n\nAssuming that you are running \
+              virt-v2v/virt-p2v on a source which is supported (and \
+              not, for example, a blank disk), then this should not \
+              happen.\n\nInspection field ‘%s’ was ‘unknown’.")
           fieldname
diff --git a/convert/target_bus_assignment.ml b/convert/target_bus_assignment.ml
index f8675cf2..54c9516b 100644
--- a/convert/target_bus_assignment.ml
+++ b/convert/target_bus_assignment.ml
@@ -81,7 +81,13 @@ let rec target_bus_assignment source_disks source_removables guestcaps =
            ignore (insert_after bus 0 t)
         | Some desired_slot_nr ->
            if not (insert_after bus desired_slot_nr t) then
-             warning (f_"removable %s device in slot %d clashes with another disk, so it has been moved to a higher numbered slot on the same bus.  This may mean that this removable device has a different name inside the guest (for example a CD-ROM originally called /dev/hdc might move to /dev/hdd, or from D: to E: on a Windows guest).")
+             warning (f_"removable %s device in slot %d clashes with another \
+                         disk, so it has been moved to a higher numbered slot \
+                         on the same bus.  This may mean that this removable \
+                         device has a different name inside the guest (for \
+                         example a CD-ROM originally called /dev/hdc might \
+                         move to /dev/hdd, or from D: to E: on a Windows \
+                         guest).")
                      (match r.s_removable_type with
                       | CDROM -> s_"CD-ROM"
                       | Floppy -> s_"floppy disk")
diff --git a/in-place/in_place.ml b/in-place/in_place.ml
index 7e531bc4..55541814 100644
--- a/in-place/in_place.ml
+++ b/in-place/in_place.ml
@@ -104,7 +104,8 @@ let rec main () =
      *)
     let rec error_unless_ip_addr what addr =
       if not (PCRE.matches mac_ip_re addr) then
-        error (f_"cannot parse --mac ip %s: doesn’t look like “%s” is an IP address") what addr
+        error (f_"cannot parse --mac ip %s: doesn’t look like “%s” is \
+                  an IP address") what addr
     in
     error_unless_ip_addr "ipaddr" if_ip_address;
     Option.may (error_unless_ip_addr "gw") if_default_gateway;
@@ -115,7 +116,8 @@ let rec main () =
       | Some len ->
          let len =
            try int_of_string len with
-           | Failure _ -> error (f_"cannot parse --mac ip prefix length field as an integer: %s") len in
+           | Failure _ -> error (f_"cannot parse --mac ip prefix length \
+                                    field as an integer: %s") len in
          if len < 0 || len > 128 then
            error (f_"--mac ip prefix length field is out of range");
          Some len in
@@ -254,7 +256,8 @@ read the man page virt-v2v-in-place(1).
           let { Xml.uri_server = server; uri_scheme = scheme } =
             try Xml.parse_uri orig_uri
             with Invalid_argument msg ->
-              error (f_"could not parse '-ic %s'.  Original error message was: %s")
+              error (f_"could not parse '-ic %s'.  Original error \
+                        message was: %s")
                 orig_uri msg in
 
           match server, scheme with
@@ -357,7 +360,12 @@ and check_host_free_space () =
   debug "check_host_free_space: large_tmpdir=%s free_space=%Ld"
         large_tmpdir free_space;
   if free_space < 1_073_741_824L then
-    error (f_"insufficient free space in the conversion server temporary directory %s (%s).\n\nEither free up space in that directory, or set the LIBGUESTFS_CACHEDIR environment variable to point to another directory with more than 1GB of free space.\n\nSee also the virt-v2v(1) manual, section \"Minimum free space check in the host\".")
+    error (f_"insufficient free space in the conversion server temporary \
+              directory %s (%s).\n\nEither free up space in that directory, \
+              or set the LIBGUESTFS_CACHEDIR environment variable to point \
+              to another directory with more than 1GB of free space.\n\n\
+              See also the virt-v2v(1) manual, section \"Minimum free \
+              space check in the host\".")
           large_tmpdir (human_size free_space)
 
 let () = run_main_and_handle_errors main
diff --git a/input/OVA.ml b/input/OVA.ml
index 09ceee98..e26059bf 100644
--- a/input/OVA.ml
+++ b/input/OVA.ml
@@ -118,11 +118,15 @@ let rec parse_ova ova =
              untar ~format ova tmpdir;
              tmpdir, Directory
           | `Zip | `GZip | `XZ | `Unknown ->
-             error (f_"%s: unsupported file format\n\nFormats which we currently understand for '-i ova' are: tar (uncompressed, compress with gzip or xz), zip") ova
+             error (f_"%s: unsupported file format\n\nFormats which we \
+                       currently understand for '-i ova' are: tar \
+                       (uncompressed, compress with gzip or xz), zip") ova
          )
 
       | `Unknown ->
-         error (f_"%s: unsupported file format\n\nFormats which we currently understand for '-i ova' are: tar (uncompressed, compress with gzip or xz), zip") ova
+         error (f_"%s: unsupported file format\n\nFormats which we \
+                   currently understand for '-i ova' are: tar (uncompressed, \
+                   compress with gzip or xz), zip") ova
     ) in
 
   (* Exploded path must be absolute (RHBZ#1155121). *)
@@ -140,7 +144,8 @@ let rec parse_ova ova =
    * so it is readable by qemu.qemu.  This is libvirt bug RHBZ#890291.
    *)
   if Unix.geteuid () = 0 && backend_is_libvirt () then (
-    warning (f_"making OVA directory public readable to work around libvirt bug https://bugzilla.redhat.com/1045069");
+    warning (f_"making OVA directory public readable to work around \
+                libvirt bug https://bugzilla.redhat.com/1045069");
     let what =
       match ova_type with
       | Directory -> [ top_dir ]
@@ -348,7 +353,8 @@ let resolve_href ({ top_dir; ova_type } as t) href =
      (try
         let filename = Realpath.realpath filename in
         if not (String.is_prefix filename real_top_dir) then
-          error (f_"-i ova: invalid OVA file: path ‘%s’ references a file outside the archive") href;
+          error (f_"-i ova: invalid OVA file: path ‘%s’ references a file \
+                    outside the archive") href;
         Some (LocalFile filename)
       with
         Unix_error (ENOENT, "realpath", _) -> None
diff --git a/input/OVF.ml b/input/OVF.ml
index 16c0b09c..48d5a684 100644
--- a/input/OVF.ml
+++ b/input/OVF.ml
@@ -99,7 +99,8 @@ let rec parse_ovf_from_ova ovf_filename =
     | "bios" -> BIOS
     | "efi" -> UEFI
     | s ->
-       error (f_"unknown Config:firmware value %s (expected \"bios\" or \"efi\")") s in
+       error (f_"unknown Config:firmware value %s (expected \"bios\" \
+                 or \"efi\")") s in
 
   name, memory, vcpu, cpu_topology, firmware,
   parse_disks xpathctx, parse_removables xpathctx, parse_nics xpathctx
@@ -254,10 +255,13 @@ and parent_controller xpathctx id =
   | Some 6 -> Some Source_SCSI
   | Some 20 -> Some Source_SATA
   | None ->
-     warning (f_"ova disk has no parent controller, please report this as a bug supplying the *.ovf file extracted from the ova");
+     warning (f_"ova disk has no parent controller, please report this as \
+                 a bug supplying the *.ovf file extracted from the ova");
      None
   | Some controller ->
-     warning (f_"ova disk has an unknown VMware controller type (%d), please report this as a bug supplying the *.ovf file extracted from the ova")
+     warning (f_"ova disk has an unknown VMware controller type (%d), please \
+                 report this as a bug supplying the *.ovf file extracted \
+                 from the ova")
              controller;
      None
 
diff --git a/input/input_disk.ml b/input/input_disk.ml
index 508adf9d..279250fe 100644
--- a/input/input_disk.ml
+++ b/input/input_disk.ml
@@ -40,7 +40,8 @@ module Disk = struct
       error (f_"no -io (input options) are allowed here");
 
     if args = [] then
-      error (f_"-i disk: expecting a disk image (filename) on the command line");
+      error (f_"-i disk: expecting a disk image (filename) \
+                on the command line");
 
     (* Check the input files exist and are readable. *)
     List.iter (fun disk -> access disk [R_OK]) args;
@@ -88,7 +89,8 @@ module Disk = struct
 
     (* Check nbdkit is installed. *)
     if not (Nbdkit.is_installed ()) then
-      error (f_"nbdkit is not installed or not working.  It is required to use ‘-i disk’.");
+      error (f_"nbdkit is not installed or not working.  It is required to \
+                use ‘-i disk’.");
 
     if not (Nbdkit.probe_plugin "file") then
       error (f_"nbdkit-file-plugin is not installed or not working");
diff --git a/input/input_libvirt.ml b/input/input_libvirt.ml
index 9311e89a..9e40fab5 100644
--- a/input/input_libvirt.ml
+++ b/input/input_libvirt.ml
@@ -38,7 +38,8 @@ let rec get_source_from_libvirt options args =
     match args with
     | [arg] -> arg
     | _ ->
-       error (f_"-i libvirt: expecting a libvirt guest name on the command line") in
+       error (f_"-i libvirt: expecting a libvirt guest name \
+                 on the command line") in
 
   (* Connect to the hypervisor. *)
   let conn =
@@ -55,7 +56,8 @@ and get_source_from_libvirt_xml _ args =
     match args with
     | [arg] -> arg
     | _ ->
-       error (f_"-i libvirtxml: expecting a libvirt XML filename on the command line") in
+       error (f_"-i libvirtxml: expecting a libvirt XML filename \
+                 on the command line") in
   let xml = read_whole_file xmlfile in
   let source, disks = parse_libvirt_xml xml in
   source, disks
@@ -63,7 +65,8 @@ and get_source_from_libvirt_xml _ args =
 and setup_servers options dir disks =
   (* Check nbdkit is installed. *)
   if not (Nbdkit.is_installed ()) then
-    error (f_"nbdkit is not installed or not working.  It is required to use ‘-i libvirt|libvirtxml’.");
+    error (f_"nbdkit is not installed or not working.  It is required to \
+              use ‘-i libvirt|libvirtxml’.");
 
   if not (Nbdkit.probe_plugin "file") then
     error (f_"nbdkit-file-plugin is not installed or not working");
diff --git a/input/input_ova.ml b/input/input_ova.ml
index 8ec1f802..7404acc3 100644
--- a/input/input_ova.ml
+++ b/input/input_ova.ml
@@ -76,14 +76,16 @@ module OVA = struct
         match r with
         | Checksums.Good_checksum -> ()
         | Checksums.Mismatched_checksum (_, actual) ->
-           error (f_"-i ova: corrupt OVA: checksum of disk %s does not match manifest (actual = %s, expected = %s)")
+           error (f_"-i ova: corrupt OVA: checksum of disk %s does not match \
+                     manifest (actual = %s, expected = %s)")
              filename actual (Checksums.string_of_csum_t csum)
         | Checksums.Missing_file ->
            (* RHBZ#1570407: Some OVA files generated by VMware
             * reference non-existent components in the *.mf file.
             * Generate a warning and ignore it.
             *)
-           warning (f_"manifest has a checksum for non-existent file %s (ignored)")
+           warning (f_"manifest has a checksum for non-existent file %s \
+                       (ignored)")
              filename
     ) manifest;
 
@@ -234,5 +236,6 @@ module OVA = struct
     else None
 
   and error_missing_href href =
-    error (f_"-i ova: OVF references file ‘%s’ which was not found in the OVA archive") href
+    error (f_"-i ova: OVF references file ‘%s’ which was not found \
+              in the OVA archive") href
 end
diff --git a/input/input_vcenter_https.ml b/input/input_vcenter_https.ml
index 863f3a00..7c505296 100644
--- a/input/input_vcenter_https.ml
+++ b/input/input_vcenter_https.ml
@@ -67,14 +67,16 @@ module VCenterHTTPS = struct
       match args with
       | [arg] -> arg
       | _ ->
-         error (f_"-i libvirt: expecting a libvirt guest name on the command line") in
+         error (f_"-i libvirt: expecting a libvirt guest name \
+                   on the command line") in
 
     (* -ip is required in this mode, see RHBZ#1960087 *)
     let password_file =
       match options.input_password with
       | Some file -> file
       | None ->
-         error (f_"-i libvirt: expecting -ip passwordfile parameter for vCenter connection") in
+         error (f_"-i libvirt: expecting -ip passwordfile parameter for \
+                   vCenter connection") in
 
     (* -ic must be set and it must contain a server.  This is
      * enforced by virt-v2v.
@@ -83,7 +85,8 @@ module VCenterHTTPS = struct
       match options.input_conn with
       | Some ic -> ic
       | None ->
-         error (f_"-i libvirt: expecting -ic parameter for vcenter connection") in
+         error (f_"-i libvirt: expecting -ic parameter for \
+                   vcenter connection") in
 
     let uri =
       try Xml.parse_uri input_conn
@@ -95,7 +98,8 @@ module VCenterHTTPS = struct
       match uri with
       | { Xml.uri_server = Some server } -> server
       | { Xml.uri_server = None } ->
-         error (f_"-i libvirt: expecting -ic parameter to contain vcenter server name") in
+         error (f_"-i libvirt: expecting -ic parameter to contain \
+                   vcenter server name") in
 
     (* Connect to the hypervisor. *)
     let conn =
@@ -116,7 +120,8 @@ module VCenterHTTPS = struct
       match xpath_string xpathctx "/domain/vmware:datacenterpath" with
       | Some dcPath -> dcPath
       | None ->
-         error (f_"vcenter: <vmware:datacenterpath> was not found in the XML.  You need to upgrade to libvirt ≥ 1.2.20.") in
+         error (f_"vcenter: <vmware:datacenterpath> was not found in the XML.  \
+                   You need to upgrade to libvirt ≥ 1.2.20.") in
 
     List.iteri (
       fun i { d_format = format; d_type } ->
diff --git a/input/input_vddk.ml b/input/input_vddk.ml
index e48495d3..6444ce18 100644
--- a/input/input_vddk.ml
+++ b/input/input_vddk.ml
@@ -95,14 +95,18 @@ information on these settings.
 
     (* thumbprint is mandatory. *)
     if not (List.mem_assoc "thumbprint" io_options) then
-      error (f_"You must pass the ‘-io vddk-thumbprint’ option with the SSL thumbprint of the VMware server.  To find the thumbprint, see the nbdkit-vddk-plugin(1) manual.  See also the virt-v2v-input-vmware(1) manual.");
+      error (f_"You must pass the ‘-io vddk-thumbprint’ option with the \
+                SSL thumbprint of the VMware server.  To find the thumbprint, \
+                see the nbdkit-vddk-plugin(1) manual.  See also the \
+                virt-v2v-input-vmware(1) manual.");
 
     (* Get the guest name. *)
     let guest =
       match args with
       | [arg] -> arg
       | _ ->
-         error (f_"-i libvirt: expecting a libvirt guest name on the command line") in
+         error (f_"-i libvirt: expecting a libvirt guest name \
+                   on the command line") in
 
     (* -ic must be set and it must contain a server.  This is
      * enforced by virt-v2v.
@@ -111,7 +115,8 @@ information on these settings.
       match options.input_conn with
       | Some ic -> ic
       | None ->
-         error (f_"-i libvirt: expecting -ic parameter for vcenter connection") in
+         error (f_"-i libvirt: expecting -ic parameter \
+                   for vcenter connection") in
 
     if not options.read_only then
       error (f_"in-place mode does not work with VDDK source");
@@ -143,7 +148,10 @@ information on these settings.
       match xpath_string "/domain/vmware:moref" with
       | Some moref -> moref
       | None ->
-         error (f_"<vmware:moref> was not found in the output of ‘virsh dumpxml \"%s\"’.  The most likely reason is that libvirt is too old, try upgrading libvirt to ≥ 3.7.") guest in
+         error (f_"<vmware:moref> was not found in the output of \
+                   ‘virsh dumpxml \"%s\"’.  The most likely reason is that \
+                   libvirt is too old, try upgrading \
+                   libvirt to ≥ 3.7.") guest in
 
     (* It probably never happens that the server name can be missing
      * from the libvirt URI, but we need a server name to pass to
diff --git a/input/input_xen_ssh.ml b/input/input_xen_ssh.ml
index 0aad36a8..b583bd55 100644
--- a/input/input_xen_ssh.ml
+++ b/input/input_xen_ssh.ml
@@ -54,14 +54,16 @@ module XenSSH = struct
       match args with
       | [arg] -> arg
       | _ ->
-         error (f_"-i libvirt: expecting a libvirt guest name on the command line") in
+         error (f_"-i libvirt: expecting a libvirt guest name \
+                   on the command line") in
 
     (* -ic must be set. *)
     let input_conn =
       match options.input_conn with
       | Some ic -> ic
       | None ->
-         error (f_"-i libvirt: expecting -ic parameter for Xen over SSH connection") in
+         error (f_"-i libvirt: expecting -ic parameter for \
+                   Xen over SSH connection") in
 
     let uri =
       try Xml.parse_uri input_conn
@@ -82,7 +84,8 @@ module XenSSH = struct
       match uri.Xml.uri_server with
       | Some server -> server
       | None ->
-         error (f_"‘-ic %s’ URL does not contain a host name field") input_conn in
+         error (f_"‘-ic %s’ URL does not contain a host name field")
+           input_conn in
 
     let port =
       match uri.uri_port with
diff --git a/input/nbdkit_vddk.ml b/input/nbdkit_vddk.ml
index 9609c442..86d9b1a9 100644
--- a/input/nbdkit_vddk.ml
+++ b/input/nbdkit_vddk.ml
@@ -70,7 +70,8 @@ let create_vddk ?bandwidth ?config ?cookie ?cor ?libdir ~moref
     | None -> ()
     | Some libdir ->
        if not (is_directory libdir) then
-         error (f_"‘-io vddk-libdir=%s’ does not point to a directory.  See the virt-v2v-input-vmware(1) manual.") libdir
+         error (f_"‘-io vddk-libdir=%s’ does not point to a directory.  \
+                   See the virt-v2v-input-vmware(1) manual.") libdir
   in
 
   (* Check that the VDDK plugin is installed and working.  We also
diff --git a/input/parse_domain_from_vmx.ml b/input/parse_domain_from_vmx.ml
index 7aca2c24..15ee093f 100644
--- a/input/parse_domain_from_vmx.ml
+++ b/input/parse_domain_from_vmx.ml
@@ -82,7 +82,8 @@ let scp_from_remote_to_temporary uri tmpdir filename =
   if verbose () then
     eprintf "%s\n%!" cmd;
   if Sys.command cmd <> 0 then
-    error (f_"could not copy the VMX file from the remote server, see earlier error messages");
+    error (f_"could not copy the VMX file from the remote server, \
+              see earlier error messages");
   localfile
 
 (* Test if [path] exists on the remote server. *)
diff --git a/input/parse_libvirt_xml.ml b/input/parse_libvirt_xml.ml
index 65693c98..123d09f4 100644
--- a/input/parse_libvirt_xml.ml
+++ b/input/parse_libvirt_xml.ml
@@ -44,7 +44,8 @@ let get_drive_slot str offset =
   let name = String.sub str offset (String.length str - offset) in
   try Some (drive_index name)
   with Invalid_argument _ ->
-       warning (f_"could not parse device name ‘%s’ from the source libvirt XML") str;
+       warning (f_"could not parse device name ‘%s’ \
+                   from the source libvirt XML") str;
        None
 
 let parse_libvirt_xml ?conn xml =
@@ -70,7 +71,8 @@ let parse_libvirt_xml ?conn xml =
   let hypervisor =
     match xpath_string "/domain/@type" with
     | None | Some "" ->
-       error (f_"in the libvirt XML metadata, <domain type='...'> is missing or empty")
+       error (f_"in the libvirt XML metadata, <domain type='...'> \
+                 is missing or empty")
     | Some s -> source_hypervisor_of_string s in
   let name =
     match xpath_string "/domain/name/text()" with
@@ -155,7 +157,8 @@ let parse_libvirt_xml ?conn xml =
           | Some "none" ->
             LNone
           | Some t ->
-            warning (f_"<listen type='%s'> in the input libvirt XML was ignored") t;
+            warning (f_"<listen type='%s'> in the input libvirt XML \
+                        was ignored") t;
             LNoListen
         ) in
       let port =
@@ -176,10 +179,13 @@ let parse_libvirt_xml ?conn xml =
                s_keymap = keymap; s_password = password; s_listen = listen;
                s_port = port }
       | Some ("sdl"|"desktop" as t) ->
-        warning (f_"virt-v2v does not support local displays, so <graphics type='%s'> in the input libvirt XML was ignored") t;
+        warning (f_"virt-v2v does not support local displays, so \
+                    <graphics type='%s'> in the input libvirt XML was ignored")
+          t;
         None
       | Some t ->
-        warning (f_"display <graphics type='%s'> in the input libvirt XML was ignored") t;
+        warning (f_"display <graphics type='%s'> in the input \
+                    libvirt XML was ignored") t;
         None
     ) in
 
@@ -297,7 +303,8 @@ let parse_libvirt_xml ?conn xml =
              sprintf "%s://%s%s%s" driver host port (uri_quote path) in
            add_disk format controller (HTTP url)
         | Some protocol, _, _ ->
-           warning (f_"<disk type='network'> with <source protocol='%s'> was ignored")
+           warning (f_"<disk type='network'> with <source protocol='%s'> \
+                       was ignored")
                    protocol
         )
       | Some "volume" ->
@@ -323,7 +330,8 @@ let parse_libvirt_xml ?conn xml =
              | None -> ()
             );
           | Some vol_type ->
-            warning (f_"<disk type='volume'> with <volume type='%s'> was ignored") vol_type
+            warning (f_"<disk type='volume'> with <volume type='%s'> \
+                        was ignored") vol_type
           )
         )
       | Some disk_type ->
@@ -364,13 +372,15 @@ let parse_libvirt_xml ?conn xml =
            let name = String.sub dev 2 (String.length dev - 2) in
            (try Some (int_of_string name)
             with Failure _ ->
-              warning (f_"could not parse device name ‘%s’ from the source libvirt XML") dev;
+              warning (f_"could not parse device name ‘%s’ \
+                          from the source libvirt XML") dev;
               None
            )
         | Some dev ->
            let rec loop = function
              | [] ->
-                warning (f_"<target dev='%s'> was ignored because the device name could not be recognized") dev;
+                warning (f_"<target dev='%s'> was ignored because \
+                            the device name could not be recognized") dev;
                 None
              | prefix :: rest ->
                 if String.is_prefix dev prefix then (
diff --git a/input/vCenter.ml b/input/vCenter.ml
index 8a1a5655..f3bc80e2 100644
--- a/input/vCenter.ml
+++ b/input/vCenter.ml
@@ -69,7 +69,9 @@ let rec start_nbdkit_for_path ?bandwidth ?cor ?password_file
       if uri.uri_user <> None then
         error (f_"vcenter: incorrect username or password")
       else
-        error (f_"vcenter: incorrect username or password.  You might need to specify the username in the URI like this: [vpx|esx|..]://USERNAME@[etc]")
+        error (f_"vcenter: incorrect username or password.  You might need \
+                  to specify the username in the URI like this: \
+                  [vpx|esx|..]://USERNAME@[etc]")
     );
 
     if status = "404" then (
@@ -150,7 +152,8 @@ and fetch_headers_from_url password_file uri sslverify https_url =
   (match uri.uri_user, password_file with
    | None, None -> ()
    | None, Some _ ->
-      warning (f_"-ip PASSWORD_FILE parameter ignored because 'user@' was not given in the URL")
+      warning (f_"-ip PASSWORD_FILE parameter ignored because \
+                  'user@' was not given in the URL")
    | Some user, None ->
       List.push_back curl_args ("user", Some user)
    | Some user, Some password_file ->
diff --git a/inspector/inspector.ml b/inspector/inspector.ml
index 222371d5..13d58df3 100644
--- a/inspector/inspector.ml
+++ b/inspector/inspector.ml
@@ -111,7 +111,8 @@ let rec main () =
      *)
     let rec error_unless_ip_addr what addr =
       if not (PCRE.matches mac_ip_re addr) then
-        error (f_"cannot parse --mac ip %s: doesn’t look like “%s” is an IP address") what addr
+        error (f_"cannot parse --mac ip %s: doesn’t look like “%s” \
+                  is an IP address") what addr
     in
     error_unless_ip_addr "ipaddr" if_ip_address;
     Option.may (error_unless_ip_addr "gw") if_default_gateway;
@@ -122,7 +123,8 @@ let rec main () =
       | Some len ->
          let len =
            try int_of_string len with
-           | Failure _ -> error (f_"cannot parse --mac ip prefix length field as an integer: %s") len in
+           | Failure _ -> error (f_"cannot parse --mac ip prefix \
+                                    length field as an integer: %s") len in
          if len < 0 || len > 128 then
            error (f_"--mac ip prefix length field is out of range");
          Some len in
@@ -191,7 +193,8 @@ A short summary of the options is given below.  For detailed help please
 read the man page virt-v2v-inspector(1).
 ")
       prog in
-  let opthandle = create_standard_options argspec ~anon_fun ~key_opts:true ~machine_readable:true usage_msg in
+  let opthandle = create_standard_options argspec ~anon_fun ~key_opts:true
+                    ~machine_readable:true usage_msg in
   Getopt.parse opthandle.getopt;
 
   (* Print the version, easier than asking users to tell us. *)
@@ -260,7 +263,8 @@ read the man page virt-v2v-inspector(1).
           let { Xml.uri_server = server; uri_scheme = scheme } =
             try Xml.parse_uri orig_uri
             with Invalid_argument msg ->
-              error (f_"could not parse '-ic %s'.  Original error message was: %s")
+              error (f_"could not parse '-ic %s'.  \
+                        Original error message was: %s")
                 orig_uri msg in
 
           match server, scheme, input_transport with
@@ -290,7 +294,9 @@ read the man page virt-v2v-inspector(1).
 
           (* Unknown remote scheme. *)
           | Some _, Some _, _ ->
-             warning (f_"no support for remote libvirt connections to '-ic %s'.  The conversion may fail when it tries to read the source disks.") orig_uri;
+             warning (f_"no support for remote libvirt connections \
+                         to '-ic %s'.  The conversion may fail when it \
+                         tries to read the source disks.") orig_uri;
              (module Input_libvirt.Libvirt_) in
 
   let input_options = {
@@ -374,8 +380,14 @@ and check_host_free_space () =
   debug "check_host_free_space: large_tmpdir=%s free_space=%Ld"
         large_tmpdir free_space;
   if free_space < 1_073_741_824L then
-    error (f_"insufficient free space in the conversion server temporary directory %s (%s).\n\nEither free up space in that directory, or set the LIBGUESTFS_CACHEDIR environment variable to point to another directory with more than 1GB of free space.\n\nSee also the virt-v2v(1) manual, section \"Minimum free space check in the host\".")
-          large_tmpdir (human_size free_space)
+    error (f_"insufficient free space in the conversion server \
+              temporary directory %s (%s).\n\nEither free up space \
+              in that directory, or set the LIBGUESTFS_CACHEDIR \
+              environment variable to point to another directory \
+              with more than 1GB of free space.\n\nSee also the \
+              virt-v2v(1) manual, section \
+              \"Minimum free space check in the host\".")
+      large_tmpdir (human_size free_space)
 
 (* This is a copy of {!Output.get_disks}. *)
 and get_disks dir =
diff --git a/lib/create_ovf.ml b/lib/create_ovf.ml
index 79b32857..5e444868 100644
--- a/lib/create_ovf.ml
+++ b/lib/create_ovf.ml
@@ -515,13 +515,17 @@ let create_meta_files output_alloc output_format sd_uuid image_uuids sizes =
     | "raw" -> "RAW"
     | "qcow2" -> "COW"
     | _ ->
-       error (f_"RHV does not support the output format ‘%s’, only raw or qcow2") output_format in
+       error (f_"RHV does not support the output format ‘%s’, \
+                 only raw or qcow2") output_format in
 
   List.mapi (
     fun i (virtual_size, image_uuid) ->
       let size_in_sectors =
         if virtual_size &^ 511L <> 0L then
-          error (f_"the virtual size of the input disk %d is not an exact multiple of 512 bytes.  The virtual size is: %Ld.\n\nThis probably means something unexpected is going on, so please file a bug about this issue.")
+          error (f_"the virtual size of the input disk %d is not an \
+                    exact multiple of 512 bytes.  The virtual size is: \
+                    %Ld.\n\nThis probably means something unexpected is \
+                    going on, so please file a bug about this issue.")
             i virtual_size;
         virtual_size /^ 512L in
 
@@ -782,7 +786,10 @@ let rec create_ovf source inspect
    *)
   (match source with
   | { s_display = Some { s_password = Some _ } } ->
-    warning (f_"This guest required a password for connection to its display, but this is not supported by RHV.  Therefore the converted guest’s display will not require a separate password to connect.");
+    warning (f_"This guest required a password for connection to its display, \
+                but this is not supported by RHV.  Therefore the converted \
+                guest’s display will not require a separate password \
+                to connect.");
     | _ -> ());
 
   if verbose () then (
@@ -871,7 +878,8 @@ and add_disks sizes guestcaps output_alloc output_format
         | "raw" -> "RAW"
         | "qcow2" -> "COW"
         | _ ->
-          error (f_"RHV does not support the output format ‘%s’, only raw or qcow2") output_format in
+          error (f_"RHV does not support the output format ‘%s’, \
+                    only raw or qcow2") output_format in
 
       (* Note: Upper case in the .meta, mixed case in the OVF. *)
       let output_alloc_for_rhv =
diff --git a/lib/libvirt_utils.ml b/lib/libvirt_utils.ml
index 1a24b049..da5cbd5e 100644
--- a/lib/libvirt_utils.ml
+++ b/lib/libvirt_utils.ml
@@ -28,7 +28,8 @@ let auth_for_password_file ?password_file () =
   let auth_fn creds =
     List.map (
       function
-      | { Libvirt.Connect.typ = Libvirt.Connect.CredentialPassphrase } -> password
+      | { Libvirt.Connect.typ = Libvirt.Connect.CredentialPassphrase } ->
+         password
       | _ -> None
     ) creds
   in
@@ -65,7 +66,8 @@ let get_domain conn name =
   if not (String.is_prefix uri "test:") then (
     (match (Libvirt.Domain.get_info dom).Libvirt.Domain.state with
     | InfoRunning | InfoBlocked | InfoPaused ->
-      error (f_"libvirt domain ‘%s’ is running or paused.  It must be shut down in order to perform virt-v2v conversion")
+      error (f_"libvirt domain ‘%s’ is running or paused.  It must be \
+                shut down in order to perform virt-v2v conversion")
         (Libvirt.Domain.get_name dom)
     | InfoNoState | InfoShutdown | InfoShutoff | InfoCrashed | InfoPMSuspended ->
       ()
@@ -84,7 +86,11 @@ let get_pool conn name =
     (try
       Libvirt.Pool.lookup_by_name conn name
     with Libvirt.Virterror { code = VIR_ERR_NO_STORAGE_POOL; message } ->
-      error (f_"cannot find libvirt pool ‘%s’: %s\n\nUse ‘virsh pool-list --all’ to list all available pools, and ‘virsh pool-dumpxml <pool>’ to display details about a particular pool.\n\nTo set the pool which virt-v2v uses, add the ‘-os <pool>’ option.")
+      error (f_"cannot find libvirt pool ‘%s’: %s\n\nUse \
+                ‘virsh pool-list --all’ to list all available pools, \
+                and ‘virsh pool-dumpxml <pool>’ to display details \
+                about a particular pool.\n\nTo set the pool which \
+                virt-v2v uses, add the ‘-os <pool>’ option.")
         name (Option.default "" message)
     )
 
diff --git a/lib/networks.ml b/lib/networks.ml
index 93250fe4..c079814d 100644
--- a/lib/networks.ml
+++ b/lib/networks.ml
@@ -81,25 +81,30 @@ let create () = {
 let add_mac t mac vnet_type vnet =
   let mac = String.lowercase_ascii mac in
   if StringMap.mem mac t.macs then
-    error (f_"duplicate --mac parameter.  Duplicate mappings specified for MAC address %s.") mac;
+    error (f_"duplicate --mac parameter.  Duplicate mappings specified \
+              for MAC address %s.") mac;
   t.macs <- StringMap.add mac (vnet_type, vnet) t.macs
 
 let add_network t i o =
   if StringMap.mem i t.network_map then
-    error (f_"duplicate -n/--network parameter.  Duplicate mappings specified for network %s.") i;
+    error (f_"duplicate -n/--network parameter.  Duplicate mappings \
+              specified for network %s.") i;
   t.network_map <- StringMap.add i o t.network_map
 
 let add_default_network t o =
   if t.default_network <> None then
-    error (f_"duplicate -n/--network parameter.  Only one default mapping is allowed.");
+    error (f_"duplicate -n/--network parameter.  Only one \
+              default mapping is allowed.");
   t.default_network <- Some o
 
 let add_bridge t i o =
   if StringMap.mem i t.bridge_map then
-    error (f_"duplicate -b/--bridge parameter.  Duplicate mappings specified for bridge %s.") i;
+    error (f_"duplicate -b/--bridge parameter.  Duplicate mappings \
+              specified for bridge %s.") i;
   t.bridge_map <- StringMap.add i o t.bridge_map
 
 let add_default_bridge t o =
   if t.default_bridge <> None then
-    error (f_"duplicate -b/--bridge parameter.  Only one default mapping is allowed.");
+    error (f_"duplicate -b/--bridge parameter.  Only one default mapping \
+              is allowed.");
   t.default_bridge <- Some o
diff --git a/lib/types.ml b/lib/types.ml
index 7ffb868b..f21c30bd 100644
--- a/lib/types.ml
+++ b/lib/types.ml
@@ -248,7 +248,8 @@ and string_of_source_display { s_display_type = typ;
     | LAddress a -> sprintf " listening on address %s" a
     | LNetwork n -> sprintf " listening on network %s" n
     | LSocket (Some s) -> sprintf " listening on Unix domain socket %s" s
-    | LSocket None -> sprintf " listening on automatically created Unix domain socket"
+    | LSocket None ->
+       sprintf " listening on automatically created Unix domain socket"
     | LNone -> " listening on private fd"
     )
 
diff --git a/lib/utils.ml b/lib/utils.ml
index 26e7e259..281868b5 100644
--- a/lib/utils.ml
+++ b/lib/utils.ml
@@ -80,7 +80,8 @@ let find_uefi_firmware guest_arch =
              guest_arch in
   let rec loop = function
     | [] ->
-       error (f_"cannot find firmware for UEFI guests.\n\nYou probably need to install OVMF (x86-64), or AAVMF (aarch64)")
+       error (f_"cannot find firmware for UEFI guests.\n\nYou probably \
+                 need to install OVMF (x86-64), or AAVMF (aarch64)")
     | ({ Uefi.code; vars = vars_template } as ret) :: rest ->
        if Sys.file_exists code && Sys.file_exists vars_template then ret
        else loop rest
@@ -197,7 +198,9 @@ and libvirt_qemu_user =
 let error_if_no_ssh_agent () =
   try ignore (Sys.getenv "SSH_AUTH_SOCK")
   with Not_found ->
-    error (f_"ssh-agent authentication has not been set up ($SSH_AUTH_SOCK is not set).  This is required by qemu to do passwordless ssh access.  See the virt-v2v(1) man page for more information.")
+    error (f_"ssh-agent authentication has not been set up ($SSH_AUTH_SOCK \
+              is not set).  This is required by qemu to do passwordless \
+              ssh access.  See the virt-v2v(1) man page for more information.")
 
 (* Create the directory containing inX and outX sockets. *)
 let create_v2v_directory () =
diff --git a/output/create_libvirt_xml.ml b/output/create_libvirt_xml.ml
index bd01304d..e1c1f616 100644
--- a/output/create_libvirt_xml.ml
+++ b/output/create_libvirt_xml.ml
@@ -392,7 +392,9 @@ let create_libvirt_xml ?pool source inspect
           * so target_ide_bus must be empty, otherwise we give a warning.
           *)
          if Array.length target_buses.target_ide_bus > 0 then
-           warning "machine type virt does not support IDE and SATA legacy devices, some legacy devices of this guest have been dropped from the libvirt output";
+           warning "machine type virt does not support IDE and SATA legacy \
+                    devices, some legacy devices of this guest have been \
+                    dropped from the libvirt output";
          [] in
     List.push_back_list devices ide_disks;
     List.push_back_list devices
diff --git a/output/output.ml b/output/output.ml
index 6065e592..e419c13d 100644
--- a/output/output.ml
+++ b/output/output.ml
@@ -76,7 +76,8 @@ let output_to_local_file ?(changeuid = fun f -> f ()) ?(compressed = false)
       output_alloc output_format filename size socket =
   (* Check nbdkit is installed and has the required plugin. *)
   if not (Nbdkit.is_installed ()) then
-    error (f_"nbdkit is not installed or not working.  It is required to use ‘-o disk’.");
+    error (f_"nbdkit is not installed or not working.  It is required \
+              to use ‘-o disk’.");
   if not (Nbdkit.probe_plugin "file") then
     error (f_"nbdkit-file-plugin is not installed or not working");
   let nbdkit_config = Nbdkit.config () in
diff --git a/output/output_glance.ml b/output/output_glance.ml
index e6a7f789..08c0c935 100644
--- a/output/output_glance.ml
+++ b/output/output_glance.ml
@@ -63,7 +63,10 @@ module Glance = struct
      * program exits early.
      *)
     if shell_command "glance image-list > /dev/null" <> 0 then
-      error (f_"glance: glance client is not installed or set up correctly.  You may need to set environment variables or source a script to enable authentication.  See preceding messages for details.");
+      error (f_"glance: glance client is not installed or set up correctly.  \
+                You may need to set environment variables or source a script \
+                to enable authentication.  \
+                See preceding messages for details.");
 
     (* When debugging, query the glance client for its version. *)
     if verbose () then (
diff --git a/output/output_kubevirt.ml b/output/output_kubevirt.ml
index 00e6a8a5..d41b5d8e 100644
--- a/output/output_kubevirt.ml
+++ b/output/output_kubevirt.ml
@@ -58,9 +58,11 @@ module Kubevirt = struct
     let output_storage =
       match options.output_storage with
       | None ->
-         error (f_"-o kubevirt: output directory was not specified, use '-os /dir'")
+         error (f_"-o kubevirt: output directory was not specified, \
+                   use '-os /dir'")
       | Some d when not (is_directory d) ->
-         error (f_"-os %s: output directory does not exist or is not a directory") d
+         error (f_"-os %s: output directory does not exist or \
+                   is not a directory") d
       | Some d -> d in
 
     let output_name = Option.default source.s_name options.output_name in
diff --git a/output/output_libvirt.ml b/output/output_libvirt.ml
index 04b4c5f8..19171a53 100644
--- a/output/output_libvirt.ml
+++ b/output/output_libvirt.ml
@@ -94,7 +94,13 @@ module Libvirt_ = struct
 
     (* Does the domain already exist on the target?  (RHBZ#889082) *)
     if Libvirt_utils.domain_exists conn output_name then
-      error (f_"a libvirt domain called ‘%s’ already exists on the target.\n\nIf using virt-v2v directly, use the ‘-on’ option to select a different name. Or delete the existing domain on the target using the ‘virsh undefine’ command.\n\nIf using virt-p2v, select a different ‘Name’ in the ‘Target properties’. Or delete the existing domain on the target using the ‘virsh undefine’ command.")
+      error (f_"a libvirt domain called ‘%s’ already exists on the \
+                target.\n\nIf using virt-v2v directly, use the ‘-on’ \
+                option to select a different name. Or delete the \
+                existing domain on the target using the ‘virsh undefine’ \
+                command.\n\nIf using virt-p2v, select a different ‘Name’ \
+                in the ‘Target properties’. Or delete the existing domain \
+                on the target using the ‘virsh undefine’ command.")
         output_name;
 
     (* Connect to output libvirt instance and check that the pool exists
@@ -112,9 +118,13 @@ module Libvirt_ = struct
     let target_path =
       match xpath_string "/pool/target/path/text()" with
       | None ->
-         error (f_"-o libvirt: output pool ‘%s’ does not have /pool/target/path element.  See virt-v2v-output-local(1)") output_pool
+         error (f_"-o libvirt: output pool ‘%s’ does not have \
+                   /pool/target/path element.  See \
+                   virt-v2v-output-local(1)") output_pool
       | Some dir when not (is_directory dir) ->
-         error (f_"-o libvirt: output pool ‘%s’ has type='dir' but the /pool/target/path element is not a local directory.  See virt-v2v-output-local(1)") output_pool
+         error (f_"-o libvirt: output pool ‘%s’ has type='dir' but the \
+                   /pool/target/path element is not a local directory.  \
+                   See virt-v2v-output-local(1)") output_pool
       | Some dir -> dir in
 
     (* Get the name of the pool, since we have to use that
@@ -194,7 +204,9 @@ module Libvirt_ = struct
        (try Unix.unlink tmpfile with _ -> ())
      with
        Libvirt.Virterror { message } ->
-       warning (f_"could not define libvirt domain: %s.\nThe libvirt XML is still available in ‘%s’.  Try running ‘virsh -c %s define %s’ yourself instead.")
+       warning (f_"could not define libvirt domain: %s.\nThe libvirt XML \
+                   is still available in ‘%s’.  Try running \
+                   ‘virsh -c %s define %s’ yourself instead.")
          (Option.default "" message) tmpfile
          (Libvirt.Connect.get_uri conn) tmpfile
     )
diff --git a/output/output_null.ml b/output/output_null.ml
index c8e27c0b..e42b07ee 100644
--- a/output/output_null.ml
+++ b/output/output_null.ml
@@ -56,7 +56,8 @@ module Null = struct
 
     (* Check nbdkit is installed and has the required plugin. *)
     if not (Nbdkit.is_installed ()) then
-      error (f_"nbdkit is not installed or not working.  It is required to use ‘-o null’.");
+      error (f_"nbdkit is not installed or not working.  \
+                It is required to use ‘-o null’.");
     if not (Nbdkit.probe_plugin "null") then
       error (f_"nbdkit-null-plugin is not installed or not working");
 
diff --git a/output/output_openstack.ml b/output/output_openstack.ml
index aa01d5a6..09776e73 100644
--- a/output/output_openstack.ml
+++ b/output/output_openstack.ml
@@ -141,7 +141,8 @@ The os-* parameters and environment variables are optional.
     let error_unless_openstack_command_exists () =
       try ignore (which openstack_binary)
       with Executable_not_found _ ->
-        error (f_"the ‘%s’ program is not available.  It is needed to communicate with OpenStack.")
+        error (f_"the ‘%s’ program is not available.  \
+                  It is needed to communicate with OpenStack.")
           openstack_binary
     in
     error_unless_openstack_command_exists ();
@@ -195,7 +196,8 @@ The os-* parameters and environment variables are optional.
      *)
     let args = [ "token"; "issue" ] in
     if run_openstack_command args <> 0 then
-      error (f_"openstack: precheck failed, there may be a problem with authentication, see earlier error messages");
+      error (f_"openstack: precheck failed, there may be a problem with \
+                authentication, see earlier error messages");
 
     let output_name = Option.default source.s_name options.output_name in
 
@@ -286,7 +288,8 @@ The os-* parameters and environment variables are optional.
       let json =
         match run_openstack_command_capture_json !args with
         | None ->
-           error (f_"openstack: failed to create a cinder volume, see earlier error messages")
+           error (f_"openstack: failed to create a cinder volume, \
+                     see earlier error messages")
         | Some json -> json in
       let id = JSON_parser.object_get_string "id" json in
 
@@ -298,13 +301,15 @@ The os-* parameters and environment variables are optional.
         (fun () ->
           match run_openstack_command_capture_json args with
           | None ->
-             error (f_"openstack: failed to query cinder volume status, see earlier error messages")
+             error (f_"openstack: failed to query cinder volume status, \
+                       see earlier error messages")
           | Some json ->
              match JSON_parser.object_get_string "status" json with
              | "creating" -> None
              | "available" -> Some () (* done *)
              | status ->
-                error (f_"openstack: unknown volume status \"%s\": expected \"creating\" or \"available\"") status
+                error (f_"openstack: unknown volume status \"%s\": \
+                          expected \"creating\" or \"available\"") status
       );
 
       id
@@ -330,7 +335,8 @@ The os-* parameters and environment variables are optional.
     let attach_volume id =
       let args = [ "server"; "add"; "volume"; server_id; id ] in
       if run_openstack_command args <> 0 then
-        error (f_"openstack: failed to attach cinder volume to VM, see earlier error messages");
+        error (f_"openstack: failed to attach cinder volume to VM, \
+                  see earlier error messages");
 
       (* We expect the disk to appear under /dev/disk/by-id.
        *
@@ -351,7 +357,8 @@ The os-* parameters and environment variables are optional.
         else id in
 
       with_timeout ~sleep:5
-        (sprintf (f_"waiting for cinder volume %s to attach to the conversion appliance") id)
+        (sprintf (f_"waiting for cinder volume %s to attach to the \
+                     conversion appliance") id)
         attach_timeout
         (fun () ->
           let entries =
@@ -428,7 +435,8 @@ The os-* parameters and environment variables are optional.
       List.push_back args id;
 
       if run_openstack_command !args <> 0 then
-        error (f_"openstack: failed to set image properties on cinder volume, see earlier error messages")
+        error (f_"openstack: failed to set image properties on cinder volume, \
+                  see earlier error messages")
     in
 
     (* Image properties are only set on the first disk.
diff --git a/output/output_qemu.ml b/output/output_qemu.ml
index 5788fc42..b667e782 100644
--- a/output/output_qemu.ml
+++ b/output/output_qemu.ml
@@ -71,7 +71,8 @@ module QEMU = struct
       | None ->
          error (f_"-o qemu: output directory was not specified, use '-os /dir'")
       | Some d when not (is_directory d) ->
-         error (f_"-os %s: output directory does not exist or is not a directory") d
+         error (f_"-os %s: output directory does not exist or is \
+                   not a directory") d
       | Some d -> d in
 
     let output_name = Option.default source.s_name options.output_name in
diff --git a/output/output_rhv.ml b/output/output_rhv.ml
index 45f831e3..08ef651b 100644
--- a/output/output_rhv.ml
+++ b/output/output_rhv.ml
@@ -88,9 +88,17 @@ module RHV = struct
       debug "RHV: actual UID:GID of new files is %d:%d" actual_uid actual_gid;
       if uid <> actual_uid || gid <> actual_gid then (
         if running_as_root then
-          warning (f_"cannot write files to the NFS server as %d:%d, even though we appear to be running as root. This probably means the NFS client or idmapd is not configured properly.\n\nYou will have to chown the files that virt-v2v creates after the run, otherwise RHV-M will not be able to import the VM.") uid gid
+          warning (f_"cannot write files to the NFS server as %d:%d, \
+                      even though we appear to be running as root. This \
+                      probably means the NFS client or idmapd is not \
+                      configured properly.\n\nYou will have to chown \
+                      the files that virt-v2v creates after the run, \
+                      otherwise RHV-M will not be able to import the VM.")
+            uid gid
         else
-          warning (f_"cannot write files to the NFS server as %d:%d. You might want to stop virt-v2v (^C) and rerun it as root.") uid gid
+          warning (f_"cannot write files to the NFS server as %d:%d. \
+                      You might want to stop virt-v2v (^C) and rerun it \
+                      as root.") uid gid
       ) in
 
     (* Create unique UUIDs for everything *)
@@ -209,7 +217,9 @@ module RHV = struct
        (* Try mounting it. *)
        let cmd = [ "mount"; sprintf "%s:%s" server export; mp ] in
        if run_command cmd <> 0 then
-         error (f_"mount command failed, see earlier errors.\n\nThis probably means you didn't specify the right %s path [-os %s], or else you need to rerun virt-v2v as root.") domain_class os;
+         error (f_"mount command failed, see earlier errors.\n\nThis probably \
+                   means you didn't specify the right %s path [-os %s], or \
+                   else you need to rerun virt-v2v as root.") domain_class os;
 
        (* Make sure it is unmounted at exit, as late as possible (prio=9999) *)
        On_exit.f ~prio:9999 (
@@ -232,7 +242,10 @@ module RHV = struct
     let entries =
       try Sys.readdir mp
       with Sys_error msg ->
-        error (f_"could not read the %s specified by the '-os %s' parameter on the command line.  Is it really an OVirt or RHV-M %s?  The original error is: %s") domain_class os domain_class msg in
+        error (f_"could not read the %s specified by the '-os %s' \
+                  parameter on the command line.  Is it really an \
+                  OVirt or RHV-M %s?  The original error is: %s")
+          domain_class os domain_class msg in
     let entries = Array.to_list entries in
     let uuids = List.filter (
         fun entry ->
@@ -244,9 +257,12 @@ module RHV = struct
       match uuids with
       | [uuid] -> uuid
       | [] ->
-         error (f_"there are no UUIDs in the %s (%s).  Is it really an OVirt or RHV-M %s?") domain_class os domain_class
+         error (f_"there are no UUIDs in the %s (%s).  Is it really an \
+                   OVirt or RHV-M %s?") domain_class os domain_class
       | _::_ ->
-         error (f_"there are multiple UUIDs in the %s (%s).  This is unexpected, and may be a bug in virt-v2v or OVirt.") domain_class os in
+         error (f_"there are multiple UUIDs in the %s (%s).  This is \
+                   unexpected, and may be a bug in virt-v2v or OVirt.")
+           domain_class os in
 
     (* Check that the domain has been attached to a Data Center by
      * checking that the master/vms directory exists.
@@ -254,7 +270,13 @@ module RHV = struct
     let () =
       let master_vms_dir = mp // uuid // "master" // "vms" in
       if not (is_directory master_vms_dir) then
-        error (f_"%s does not exist or is not a directory.\n\nMost likely cause: Either the %s (%s) has not been attached to any Data Center, or the path %s is not an %s at all.\n\nYou have to attach the %s to a Data Center using the RHV-M / OVirt user interface first.\n\nIf you don’t know what the %s mount point should be then you can also find this out through the RHV-M user interface.")
+        error (f_"%s does not exist or is not a directory.\n\nMost likely \
+                  cause: Either the %s (%s) has not been attached to any \
+                  Data Center, or the path %s is not an %s at all.\n\n\
+                  You have to attach the %s to a Data Center using the \
+                  RHV-M / OVirt user interface first.\n\nIf you don’t \
+                  know what the %s mount point should be then you can \
+                  also find this out through the RHV-M user interface.")
           master_vms_dir domain_class os os
           domain_class domain_class domain_class in
 
diff --git a/output/output_rhv_upload.ml b/output/output_rhv_upload.ml
index f2ced4f4..c84ce7a6 100644
--- a/output/output_rhv_upload.ml
+++ b/output/output_rhv_upload.ml
@@ -65,13 +65,17 @@ after their uploads (if you do, you must supply one for each disk):
     let output_conn =
       match options.output_conn with
       | None ->
-         error (f_"-o rhv-upload: use ‘-oc’ to point to the oVirt or RHV server REST API URL, which is usually https://servername/ovirt-engine/api")
+         error (f_"-o rhv-upload: use ‘-oc’ to point to the oVirt \
+                   or RHV server REST API URL, which is usually \
+                   https://servername/ovirt-engine/api")
       | Some oc -> oc in
     (* In theory we could make the password optional in future. *)
     let output_password =
       match options.output_password with
       | None ->
-         error (f_"-o rhv-upload: output password file was not specified, use ‘-op’ to point to a file which contains the password used to connect to the oVirt or RHV server")
+         error (f_"-o rhv-upload: output password file was not specified, \
+                   use ‘-op’ to point to a file which contains the password \
+                   used to connect to the oVirt or RHV server")
       | Some op -> op in
     let output_storage =
       match options.output_storage with
@@ -126,7 +130,8 @@ after their uploads (if you do, you must supply one for each disk):
     let nil_uuid = "00000000-0000-0000-0000-000000000000" in
     let rex_uuid = lazy (
       let hex = "[a-fA-F0-9]" in
-      let str = sprintf "^%s{8}-%s{4}-%s{4}-%s{4}-%s{12}$" hex hex hex hex hex in
+      let str = sprintf "^%s{8}-%s{4}-%s{4}-%s{4}-%s{12}$"
+                  hex hex hex hex hex in
       PCRE.compile str
     ) in
     if uuid = nil_uuid then false
@@ -151,13 +156,16 @@ after their uploads (if you do, you must supply one for each disk):
       let res = run_command [ Python_script.python; "-c";
                               "import ovirtsdk4" ] in
       if res <> 0 then
-        error (f_"the Python module ‘ovirtsdk4’ could not be loaded, is it installed?  See previous messages for problems.")
+        error (f_"the Python module ‘ovirtsdk4’ could not be loaded, \
+                  is it installed?  See previous messages for problems.")
     in
 
     (* Check that nbdkit is available and new enough. *)
     let error_unless_nbdkit_working () =
       if not (Nbdkit.is_installed ()) then
-        error (f_"nbdkit is not installed or not working.  It is required to use ‘-o rhv-upload’.  See the virt-v2v-output-rhv(1) manual.")
+        error (f_"nbdkit is not installed or not working.  It is required \
+                  to use ‘-o rhv-upload’.  See the virt-v2v-output-rhv(1) \
+                  manual.")
     in
 
     let error_unless_nbdkit_min_version config =
@@ -175,7 +183,8 @@ after their uploads (if you do, you must supply one for each disk):
                   (quote (Python_script.path plugin_script)) in
       debug "%s" cmd;
       if Sys.command cmd <> 0 then
-        error (f_"nbdkit python plugin is not installed or not working.  It is required if you want to use ‘-o rhv-upload’.
+        error (f_"nbdkit python plugin is not installed or not working.  \
+                  It is required if you want to use ‘-o rhv-upload’.
 
 See also the virt-v2v-output-rhv(1) manual.");
     in
@@ -187,7 +196,10 @@ See also the virt-v2v-output-rhv(1) manual.");
       if have_selinux then (
         let selinux = try List.assoc "selinux" config with Not_found -> "no" in
         if selinux = "no" then
-          error (f_"nbdkit was compiled without SELinux support.  You will have to recompile nbdkit with libselinux-devel installed, or else set SELinux to Permissive mode while doing the conversion.")
+          error (f_"nbdkit was compiled without SELinux support.  You will \
+                    have to recompile nbdkit with libselinux-devel installed, \
+                    or else set SELinux to Permissive mode while doing the \
+                    conversion.")
       )
     in
 
@@ -280,8 +292,9 @@ See also the virt-v2v-output-rhv(1) manual.");
       | Some uuids ->
          let nr_disks = List.length disks in
          if List.length uuids <> nr_disks then
-           error (f_"the number of ‘-oo rhv-disk-uuid’ parameters passed on th
-e command line has to match the number of guest disk images (for this guest: %d)") nr_disks;
+           error (f_"the number of ‘-oo rhv-disk-uuid’ parameters passed on \
+                     the command line has to match the number of guest \
+                     disk images (for this guest: %d)") nr_disks;
          uuids
       | None -> List.map (fun _ -> uuidgen ()) disks in
 
@@ -357,7 +370,10 @@ e command line has to match the number of guest disk images (for this guest: %d)
           | "raw" as fmt -> fmt
           | "qcow2" as fmt -> fmt
           | _ ->
-             error (f_"rhv-upload: -of %s: Only output format ‘raw’ or ‘qcow2’ is supported.  If the input is in a different format then force one of these output formats by adding either ‘-of raw’ or ‘-of qcow2’ on the command line.")
+             error (f_"rhv-upload: -of %s: Only output format ‘raw’ or ‘qcow2’ \
+                       is supported.  If the input is in a different format \
+                       then force one of these output formats by adding \
+                       either ‘-of raw’ or ‘-of qcow2’ on the command line.")
                output_format in
         let json_params =
           ("disk_format", JSON.String disk_format) :: json_params in
@@ -433,7 +449,8 @@ e command line has to match the number of guest disk images (for this guest: %d)
      | None -> assert false
      | Some arch ->
         if arch <> target_meta.guestcaps.gcaps_arch then
-          error (f_"the cluster ‘%s’ does not support the architecture %s but %s")
+          error (f_"the cluster ‘%s’ does not support the architecture %s \
+                    but %s")
             rhv_cluster_name target_meta.guestcaps.gcaps_arch arch
     );
 
diff --git a/output/output_vdsm.ml b/output/output_vdsm.ml
index 23d1b9cd..132b0cf0 100644
--- a/output/output_vdsm.ml
+++ b/output/output_vdsm.ml
@@ -94,7 +94,8 @@ For each disk you must supply one of each of these options:
     let image_uuids = List.rev !image_uuids in
     let vol_uuids = List.rev !vol_uuids in
     if image_uuids = [] || vol_uuids = [] then
-      error (f_"-o vdsm: either -oo vdsm-vol-uuid or -oo vdsm-vm-uuid was not specified");
+      error (f_"-o vdsm: either -oo vdsm-vol-uuid or \
+                -oo vdsm-vm-uuid was not specified");
     let vm_uuid =
       match !vm_uuid with
       | None ->
@@ -108,7 +109,8 @@ For each disk you must supply one of each of these options:
       match options.output_storage with
       | None -> error (f_"-o vdsm: -os option was not specified")
       | Some d when not (is_directory d) ->
-         error (f_"-os %s: output directory does not exist or is not a directory") d
+         error (f_"-os %s: output directory does not exist \
+                   or is not a directory") d
       | Some d -> d in
 
     let output_name = Option.default source.s_name options.output_name in
@@ -128,7 +130,9 @@ For each disk you must supply one of each of these options:
 
     if List.length image_uuids <> List.length disks ||
        List.length vol_uuids <> List.length disks then
-      error (f_"the number of ‘-oo vdsm-image-uuid’ and ‘-oo vdsm-vol-uuid’ parameters passed on the command line has to match the number of guest disk images (for this guest: %d)")
+      error (f_"the number of ‘-oo vdsm-image-uuid’ and ‘-oo vdsm-vol-uuid’ \
+                parameters passed on the command line has to match the \
+                number of guest disk images (for this guest: %d)")
         (List.length disks);
 
     let dd_mp, dd_uuid =
@@ -141,7 +145,8 @@ For each disk you must supply one of each of these options:
          let mp = String.concat "/" (List.rev rest) in
          mp, uuid
       | _ ->
-         error (f_"vdsm: invalid -os parameter does not contain a valid UUID: %s")
+         error (f_"vdsm: invalid -os parameter \
+                   does not contain a valid UUID: %s")
            output_storage in
 
     debug "VDSM: DD mountpoint: %s\nVDSM: DD UUID: %s" dd_mp dd_uuid;
@@ -158,7 +163,8 @@ For each disk you must supply one of each of these options:
 
     (* Note that VDSM has to create this directory too. *)
     if not (is_directory ovf_output) then
-      error (f_"OVF (metadata) directory (%s) does not exist or is not a directory")
+      error (f_"OVF (metadata) directory (%s) does not exist or \
+                is not a directory")
         ovf_output;
 
     debug "VDSM: OVF (metadata) directory: %s" ovf_output;
diff --git a/v2v/v2v.ml b/v2v/v2v.ml
index fcf5e2d4..1e8d03ef 100644
--- a/v2v/v2v.ml
+++ b/v2v/v2v.ml
@@ -123,7 +123,8 @@ let rec main () =
      *)
     let rec error_unless_ip_addr what addr =
       if not (PCRE.matches mac_ip_re addr) then
-        error (f_"cannot parse --mac ip %s: doesn’t look like “%s” is an IP address") what addr
+        error (f_"cannot parse --mac ip %s: doesn’t look like “%s” \
+                  is an IP address") what addr
     in
     error_unless_ip_addr "ipaddr" if_ip_address;
     Option.may (error_unless_ip_addr "gw") if_default_gateway;
@@ -134,7 +135,8 @@ let rec main () =
       | Some len ->
          let len =
            try int_of_string len with
-           | Failure _ -> error (f_"cannot parse --mac ip prefix length field as an integer: %s") len in
+           | Failure _ -> error (f_"cannot parse --mac ip prefix length field \
+                                    as an integer: %s") len in
          if len < 0 || len > 128 then
            error (f_"--mac ip prefix length field is out of range");
          Some len in
@@ -329,7 +331,8 @@ A short summary of the options is given below.  For detailed help please
 read the man page virt-v2v(1).
 ")
       prog in
-  let opthandle = create_standard_options argspec ~anon_fun ~key_opts:true ~machine_readable:true usage_msg in
+  let opthandle = create_standard_options argspec ~anon_fun ~key_opts:true
+                    ~machine_readable:true usage_msg in
   Getopt.parse opthandle.getopt;
 
   (* Print the version, easier than asking users to tell us. *)
@@ -420,7 +423,8 @@ read the man page virt-v2v(1).
           let { Xml.uri_server = server; uri_scheme = scheme } =
             try Xml.parse_uri orig_uri
             with Invalid_argument msg ->
-              error (f_"could not parse '-ic %s'.  Original error message was: %s")
+              error (f_"could not parse '-ic %s'.  \
+                        Original error message was: %s")
                 orig_uri msg in
 
           match server, scheme, input_transport with
@@ -450,7 +454,9 @@ read the man page virt-v2v(1).
 
           (* Unknown remote scheme. *)
           | Some _, Some _, _ ->
-             warning (f_"no support for remote libvirt connections to '-ic %s'.  The conversion may fail when it tries to read the source disks.") orig_uri;
+             warning (f_"no support for remote libvirt connections to \
+                         '-ic %s'.  The conversion may fail when it tries \
+                         to read the source disks.") orig_uri;
              (module Input_libvirt.Libvirt_) in
 
   let input_options = {
@@ -627,8 +633,14 @@ and check_host_free_space () =
   debug "check_host_free_space: large_tmpdir=%s free_space=%Ld"
         large_tmpdir free_space;
   if free_space < 1_073_741_824L then
-    error (f_"insufficient free space in the conversion server temporary directory %s (%s).\n\nEither free up space in that directory, or set the LIBGUESTFS_CACHEDIR environment variable to point to another directory with more than 1GB of free space.\n\nSee also the virt-v2v(1) manual, section \"Minimum free space check in the host\".")
-          large_tmpdir (human_size free_space)
+    error (f_"insufficient free space in the conversion server \
+              temporary directory %s (%s).\n\nEither free up space \
+              in that directory, or set the LIBGUESTFS_CACHEDIR \
+              environment variable to point to another directory \
+              with more than 1GB of free space.\n\nSee also the \
+              virt-v2v(1) manual, section \
+              \"Minimum free space check in the host\".")
+      large_tmpdir (human_size free_space)
 
 and nbdcopy ?request_size output_alloc input_uri output_uri =
   (* XXX It's possible that some output modes know whether
